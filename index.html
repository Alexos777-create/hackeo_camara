<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Camera Access</title>
</head>
<body>
    <style>
        video {
            display: block;
            max-width: 100%;
            width: 640px;
            height: auto;
            border: 1px solid #ccc;
        }
        #preview {
            display: block;
            margin-top: 12px;
            max-width: 100%;
            width: 640px;
            border: 1px solid #ccc;
        }
    </style>
    <script src="/socket.io/socket.io.js"></script>
    <script>
        const pcConfig = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
        const socket = io();
        const room = new URLSearchParams(window.location.search).get('room') || 'default';
        let localStream = null;
        const pcs = {}; // viewerId -> RTCPeerConnection

        async function startPublisher() {
            socket.emit('join', { room, role: 'publisher' });

            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                const videoDevices = devices.filter(d => d.kind === 'videoinput');
                if (videoDevices.length === 0) {
                    console.error('No se encontró ninguna cámara en el dispositivo');
                    return;
                }
                const deviceId = videoDevices[0].deviceId;

                localStream = await navigator.mediaDevices.getUserMedia({
                    video: { deviceId: deviceId, width: { ideal: 1280 }, height: { ideal: 720 } },
                    audio: true
                });

                const localVideo = document.createElement('video');
                localVideo.id = 'localVideo';
                localVideo.autoplay = true;
                localVideo.muted = true;
                localVideo.playsInline = true;
                localVideo.srcObject = localStream;
                document.body.appendChild(localVideo);
            } catch (err) {
                console.error('Error obteniendo media:', err);
            }
        }

        socket.on('viewer-joined', async ({ viewerId }) => {
            console.log('Viewer joined:', viewerId);
            if (!localStream) return;

            const pc = new RTCPeerConnection(pcConfig);
            pcs[viewerId] = pc;

            localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

            pc.onicecandidate = (e) => {
                if (e.candidate) {
                    socket.emit('candidate', { to: viewerId, candidate: e.candidate });
                }
            };

            pc.onconnectionstatechange = () => {
                if (pc.connectionState === 'disconnected' || pc.connectionState === 'failed') {
                    pc.close();
                    delete pcs[viewerId];
                }
            };

            const offer = await pc.createOffer();
            await pc.setLocalDescription(offer);
            socket.emit('offer-to', { to: viewerId, sdp: pc.localDescription });
        });

        socket.on('answer', async ({ sdp, from }) => {
            const pc = pcs[from];
            if (!pc) {
                console.warn('No peer connection for', from);
                return;
            }
            await pc.setRemoteDescription(new RTCSessionDescription(sdp));
        });

        socket.on('candidate', async ({ candidate, from }) => {
            const pc = pcs[from];
            if (pc) {
                try {
                    await pc.addIceCandidate(new RTCIceCandidate(candidate));
                } catch (err) {
                    console.warn('Error adding candidate:', err);
                }
            }
        });

        socket.on('connect', () => {
            startPublisher();
        });
    </script>
</body>
</html>